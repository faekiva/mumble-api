//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.3
//
// <auto-generated>
//
// Generated from file `Murmur.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//


import * as iceNS0 from "ice"
export namespace Murmur
{
    /**
     * A network address in IPv6 format.
     */
    type NetAddress = Uint8Array;

    class NetAddressHelper
    {
        static write(outs:iceNS0.Ice.OutputStream, value:NetAddress):void;
        static read(ins:iceNS0.Ice.InputStream):NetAddress;
    }

    /**
     * A connected user.
     */
    class User
    {
        constructor(session?:number, userid?:number, mute?:boolean, deaf?:boolean, suppress?:boolean, prioritySpeaker?:boolean, selfMute?:boolean, selfDeaf?:boolean, recording?:boolean, channel?:number, name?:string, onlinesecs?:number, bytespersec?:number, version?:number, release?:string, os?:string, osversion?:string, identity?:string, context?:string, comment?:string, address?:NetAddress, tcponly?:boolean, idlesecs?:number, udpPing?:number, tcpPing?:number);
        clone():User;
        equals(rhs:any):boolean;
        session:number;
        userid:number;
        mute:boolean;
        deaf:boolean;
        suppress:boolean;
        prioritySpeaker:boolean;
        selfMute:boolean;
        selfDeaf:boolean;
        recording:boolean;
        channel:number;
        name:string;
        onlinesecs:number;
        bytespersec:number;
        version:number;
        release:string;
        os:string;
        osversion:string;
        identity:string;
        context:string;
        comment:string;
        address:NetAddress;
        tcponly:boolean;
        idlesecs:number;
        udpPing:number;
        tcpPing:number;
        static write(outs:iceNS0.Ice.OutputStream, value:User):void;
        static read(ins:iceNS0.Ice.InputStream):User;
    }

    type IntList = number[];

    class IntListHelper
    {
        static write(outs:iceNS0.Ice.OutputStream, value:IntList):void;
        static read(ins:iceNS0.Ice.InputStream):IntList;
    }

    /**
     * A text message between users.
     */
    class TextMessage
    {
        constructor(sessions?:IntList, channels?:IntList, trees?:IntList, text?:string);
        clone():TextMessage;
        equals(rhs:any):boolean;
        hashCode():number;
        sessions:IntList;
        channels:IntList;
        trees:IntList;
        text:string;
        static write(outs:iceNS0.Ice.OutputStream, value:TextMessage):void;
        static read(ins:iceNS0.Ice.InputStream):TextMessage;
    }

    /**
     * A channel.
     */
    class Channel
    {
        constructor(id?:number, name?:string, parent?:number, links?:IntList, description?:string, temporary?:boolean, position?:number);
        clone():Channel;
        equals(rhs:any):boolean;
        hashCode():number;
        id:number;
        name:string;
        parent:number;
        links:IntList;
        description:string;
        temporary:boolean;
        position:number;
        static write(outs:iceNS0.Ice.OutputStream, value:Channel):void;
        static read(ins:iceNS0.Ice.InputStream):Channel;
    }

    /**
     * A group. Groups are defined per channel, and can inherit members from parent channels.
     */
    class Group
    {
        constructor(name?:string, inherited?:boolean, inherit?:boolean, inheritable?:boolean, add?:IntList, remove?:IntList, members?:IntList);
        clone():Group;
        equals(rhs:any):boolean;
        hashCode():number;
        name:string;
        inherited:boolean;
        inherit:boolean;
        inheritable:boolean;
        add:IntList;
        remove:IntList;
        members:IntList;
        static write(outs:iceNS0.Ice.OutputStream, value:Group):void;
        static read(ins:iceNS0.Ice.InputStream):Group;
    }

    /**
     * Write access to channel control. Implies all other permissions (except Speak).
     */
    const PermissionWrite:number;

    /**
     * Traverse channel. Without this, a client cannot reach subchannels, no matter which privileges he has there.
     */
    const PermissionTraverse:number;

    /**
     * Enter channel.
     */
    const PermissionEnter:number;

    /**
     * Speak in channel.
     */
    const PermissionSpeak:number;

    /**
     * Whisper to channel. This is different from Speak, so you can set up different permissions.
     */
    const PermissionWhisper:number;

    /**
     * Mute and deafen other users in this channel.
     */
    const PermissionMuteDeafen:number;

    /**
     * Move users from channel. You need this permission in both the source and destination channel to move another user.
     */
    const PermissionMove:number;

    /**
     * Make new channel as a subchannel of this channel.
     */
    const PermissionMakeChannel:number;

    /**
     * Make new temporary channel as a subchannel of this channel.
     */
    const PermissionMakeTempChannel:number;

    /**
     * Link this channel. You need this permission in both the source and destination channel to link channels, or in either channel to unlink them.
     */
    const PermissionLinkChannel:number;

    /**
     * Send text message to channel.
     */
    const PermissionTextMessage:number;

    /**
     * Kick user from server. Only valid on root channel.
     */
    const PermissionKick:number;

    /**
     * Ban user from server. Only valid on root channel.
     */
    const PermissionBan:number;

    /**
     * Register and unregister users. Only valid on root channel.
     */
    const PermissionRegister:number;

    /**
     * Register and unregister users. Only valid on root channel.
     */
    const PermissionRegisterSelf:number;

    /**
     * Access Control List for a channel. ACLs are defined per channel, and can be inherited from parent channels.
     */
    class ACL
    {
        constructor(applyHere?:boolean, applySubs?:boolean, inherited?:boolean, userid?:number, group?:string, allow?:number, deny?:number);
        clone():ACL;
        equals(rhs:any):boolean;
        hashCode():number;
        applyHere:boolean;
        applySubs:boolean;
        inherited:boolean;
        userid:number;
        group:string;
        allow:number;
        deny:number;
        static write(outs:iceNS0.Ice.OutputStream, value:ACL):void;
        static read(ins:iceNS0.Ice.InputStream):ACL;
    }

    /**
     * A single ip mask for a ban.
     */
    class Ban
    {
        constructor(address?:NetAddress, bits?:number, name?:string, hash?:string, reason?:string, start?:number, duration?:number);
        clone():Ban;
        equals(rhs:any):boolean;
        hashCode():number;
        address:NetAddress;
        bits:number;
        name:string;
        hash:string;
        reason:string;
        start:number;
        duration:number;
        static write(outs:iceNS0.Ice.OutputStream, value:Ban):void;
        static read(ins:iceNS0.Ice.InputStream):Ban;
    }

    /**
     * A entry in the log.
     */
    class LogEntry
    {
        constructor(timestamp?:number, txt?:string);
        clone():LogEntry;
        equals(rhs:any):boolean;
        hashCode():number;
        timestamp:number;
        txt:string;
        static write(outs:iceNS0.Ice.OutputStream, value:LogEntry):void;
        static read(ins:iceNS0.Ice.InputStream):LogEntry;
    }

    type TreeList = Murmur.Tree[];

    class TreeListHelper
    {
        static write(outs:iceNS0.Ice.OutputStream, value:TreeList):void;
        static read(ins:iceNS0.Ice.InputStream):TreeList;
    }

    class ChannelInfo
    {
        static readonly ChannelDescription:ChannelInfo;
        static readonly ChannelPosition:ChannelInfo;
        
        static valueOf(value:number):ChannelInfo;
        equals(other:any):boolean;
        hashCode():number;
        toString():string;
        
        readonly name:string;
        readonly value:number;
    }

    class UserInfo
    {
        static readonly UserName:UserInfo;
        static readonly UserEmail:UserInfo;
        static readonly UserComment:UserInfo;
        static readonly UserHash:UserInfo;
        static readonly UserPassword:UserInfo;
        static readonly UserLastActive:UserInfo;
        static readonly UserKDFIterations:UserInfo;
        
        static valueOf(value:number):UserInfo;
        equals(other:any):boolean;
        hashCode():number;
        toString():string;
        
        readonly name:string;
        readonly value:number;
    }

    class UserMap extends Map<number, User>
    {
    }

    class UserMapHelper
    {
        static write(outs:iceNS0.Ice.OutputStream, value:UserMap):void;
        static read(ins:iceNS0.Ice.InputStream):UserMap;
    }

    class ChannelMap extends Map<number, Channel>
    {
    }

    class ChannelMapHelper
    {
        static write(outs:iceNS0.Ice.OutputStream, value:ChannelMap):void;
        static read(ins:iceNS0.Ice.InputStream):ChannelMap;
    }

    type ChannelList = Channel[];

    class ChannelListHelper
    {
        static write(outs:iceNS0.Ice.OutputStream, value:ChannelList):void;
        static read(ins:iceNS0.Ice.InputStream):ChannelList;
    }

    type UserList = User[];

    class UserListHelper
    {
        static write(outs:iceNS0.Ice.OutputStream, value:UserList):void;
        static read(ins:iceNS0.Ice.InputStream):UserList;
    }

    type GroupList = Group[];

    class GroupListHelper
    {
        static write(outs:iceNS0.Ice.OutputStream, value:GroupList):void;
        static read(ins:iceNS0.Ice.InputStream):GroupList;
    }

    type ACLList = ACL[];

    class ACLListHelper
    {
        static write(outs:iceNS0.Ice.OutputStream, value:ACLList):void;
        static read(ins:iceNS0.Ice.InputStream):ACLList;
    }

    type LogList = LogEntry[];

    class LogListHelper
    {
        static write(outs:iceNS0.Ice.OutputStream, value:LogList):void;
        static read(ins:iceNS0.Ice.InputStream):LogList;
    }

    type BanList = Ban[];

    class BanListHelper
    {
        static write(outs:iceNS0.Ice.OutputStream, value:BanList):void;
        static read(ins:iceNS0.Ice.InputStream):BanList;
    }

    type IdList = number[];

    class IdListHelper
    {
        static write(outs:iceNS0.Ice.OutputStream, value:IdList):void;
        static read(ins:iceNS0.Ice.InputStream):IdList;
    }

    type NameList = string[];

    class NameListHelper
    {
        static write(outs:iceNS0.Ice.OutputStream, value:NameList):void;
        static read(ins:iceNS0.Ice.InputStream):NameList;
    }

    class NameMap extends Map<number, string>
    {
    }

    class NameMapHelper
    {
        static write(outs:iceNS0.Ice.OutputStream, value:NameMap):void;
        static read(ins:iceNS0.Ice.InputStream):NameMap;
    }

    class IdMap extends Map<string, number>
    {
    }

    class IdMapHelper
    {
        static write(outs:iceNS0.Ice.OutputStream, value:IdMap):void;
        static read(ins:iceNS0.Ice.InputStream):IdMap;
    }

    type Texture = Uint8Array;

    class TextureHelper
    {
        static write(outs:iceNS0.Ice.OutputStream, value:Texture):void;
        static read(ins:iceNS0.Ice.InputStream):Texture;
    }

    class ConfigMap extends Map<string, string>
    {
    }

    class ConfigMapHelper
    {
        static write(outs:iceNS0.Ice.OutputStream, value:ConfigMap):void;
        static read(ins:iceNS0.Ice.InputStream):ConfigMap;
    }

    type GroupNameList = string[];

    class GroupNameListHelper
    {
        static write(outs:iceNS0.Ice.OutputStream, value:GroupNameList):void;
        static read(ins:iceNS0.Ice.InputStream):GroupNameList;
    }

    type CertificateDer = Uint8Array;

    class CertificateDerHelper
    {
        static write(outs:iceNS0.Ice.OutputStream, value:CertificateDer):void;
        static read(ins:iceNS0.Ice.InputStream):CertificateDer;
    }

    type CertificateList = CertificateDer[];

    class CertificateListHelper
    {
        static write(outs:iceNS0.Ice.OutputStream, value:CertificateList):void;
        static read(ins:iceNS0.Ice.InputStream):CertificateList;
    }

    /**
     * User information map.
     * Older versions of ice-php can't handle enums as keys. If you are using one of these, replace 'UserInfo' with 'byte'.
     */
    class UserInfoMap extends Map<UserInfo, string>
    {
    }

    class UserInfoMapHelper
    {
        static write(outs:iceNS0.Ice.OutputStream, value:UserInfoMap):void;
        static read(ins:iceNS0.Ice.InputStream):UserInfoMap;
    }

    /**
     * User and subchannel state. Read-only.
     */
    class Tree extends iceNS0.Ice.Value
    {
        /**
         * One-shot constructor to initialize all data members.
         * @param c Channel definition of current channel.
         * @param children List of subchannels.
         * @param users Users in this channel.
         */
        constructor(c?:Channel, children?:TreeList, users?:UserList);
        /**
         * Channel definition of current channel.
         */
        c:Channel;
        /**
         * List of subchannels.
         */
        children:TreeList;
        /**
         * Users in this channel.
         */
        users:UserList;
    }

    class MurmurException extends iceNS0.Ice.UserException
    {
    }

    /**
     * This is thrown when you specify an invalid session. This may happen if the user has disconnected since your last call to {@link Server.getUsers}. See {@link User.session}
     */
    class InvalidSessionException extends MurmurException
    {
    }

    /**
     * This is thrown when you specify an invalid channel id. This may happen if the channel was removed by another provess. It can also be thrown if you try to add an invalid channel.
     */
    class InvalidChannelException extends MurmurException
    {
    }

    /**
     * This is thrown when you try to do an operation on a server that does not exist. This may happen if someone has removed the server.
     */
    class InvalidServerException extends MurmurException
    {
    }

    /**
     * This happens if you try to fetch user or channel state on a stopped server, if you try to stop an already stopped server or start an already started server.
     */
    class ServerBootedException extends MurmurException
    {
    }

    /**
     * This is thrown if {@link Server.start} fails, and should generally be the cause for some concern.
     */
    class ServerFailureException extends MurmurException
    {
    }

    /**
     * This is thrown when you specify an invalid userid.
     */
    class InvalidUserException extends MurmurException
    {
    }

    /**
     * This is thrown when you try to set an invalid texture.
     */
    class InvalidTextureException extends MurmurException
    {
    }

    /**
     * This is thrown when you supply an invalid callback.
     */
    class InvalidCallbackException extends MurmurException
    {
    }

    /**
     * This is thrown when you supply the wrong secret in the calling context.
     */
    class InvalidSecretException extends MurmurException
    {
    }

    /**
     * This is thrown when the channel operation would excede the channel nesting limit
     */
    class NestingLimitException extends MurmurException
    {
    }

    /**
     * This is thrown when you ask the server to disclose something that should be secret.
     */
    class WriteOnlyException extends MurmurException
    {
    }

    /**
     * This is thrown when invalid input data was specified.
     */
    class InvalidInputDataException extends MurmurException
    {
    }

    abstract class ServerCallbackPrx extends iceNS0.Ice.ObjectPrx
    {
        /**
         * Called when a user connects to the server.
         * @param state State of connected user.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        userConnected(state:User, context?:Map<string, string>):iceNS0.Ice.AsyncResult<void>;
        /**
         * Called when a user disconnects from the server. The user has already been removed, so you can no longer use methods like {@link Server.getState}
         * to retrieve the user's state.
         * @param state State of disconnected user.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        userDisconnected(state:User, context?:Map<string, string>):iceNS0.Ice.AsyncResult<void>;
        /**
         * Called when a user state changes. This is called if the user moves, is renamed, is muted, deafened etc.
         * @param state New state of user.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        userStateChanged(state:User, context?:Map<string, string>):iceNS0.Ice.AsyncResult<void>;
        /**
         * Called when user writes a text message
         * @param state the User sending the message
         * @param message the TextMessage the user has sent
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        userTextMessage(state:User, message:TextMessage, context?:Map<string, string>):iceNS0.Ice.AsyncResult<void>;
        /**
         * Called when a new channel is created.
         * @param state State of new channel.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        channelCreated(state:Channel, context?:Map<string, string>):iceNS0.Ice.AsyncResult<void>;
        /**
         * Called when a channel is removed. The channel has already been removed, you can no longer use methods like {@link Server.getChannelState}
         * @param state State of removed channel.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        channelRemoved(state:Channel, context?:Map<string, string>):iceNS0.Ice.AsyncResult<void>;
        /**
         * Called when a new channel state changes. This is called if the channel is moved, renamed or if new links are added.
         * @param state New state of channel.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        channelStateChanged(state:Channel, context?:Map<string, string>):iceNS0.Ice.AsyncResult<void>;

        /**
         * Downcasts a proxy without confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @return A proxy with the requested type.
         */
        static uncheckedCast(prx:iceNS0.Ice.ObjectPrx, facet?:string):ServerCallbackPrx;
        /**
         * Downcasts a proxy after confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @param facet A facet name.
         * @param context The context map for the invocation.
         * @return A proxy with the requested type and facet, or nil if the target proxy is nil or the target
         * object does not support the requested type.
         */
        static checkedCast(prx:iceNS0.Ice.ObjectPrx, facet?:string, contex?:Map<string, string>):iceNS0.Ice.AsyncResult<ServerCallbackPrx>;
    }

    abstract class ServerCallback extends iceNS0.Ice.Object
    {
        /**
         * Callback interface for servers. You can supply an implementation of this to receive notification
         * messages from the server.
         * If an added callback ever throws an exception or goes away, it will be automatically removed.
         * Please note that all callbacks are done asynchronously; murmur does not wait for the callback to
         * complete before continuing processing.
         * Note that callbacks are removed when a server is stopped, so you should have a callback for
         * {@link MetaCallback.started} which calls {@link Server.addCallback}.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         * @see MetaCallback
         * @see Server.addCallback
         */
        abstract userConnected(state:User, current:iceNS0.Ice.Current):PromiseLike<void>|void;
        /**
         * Callback interface for servers. You can supply an implementation of this to receive notification
         * messages from the server.
         * If an added callback ever throws an exception or goes away, it will be automatically removed.
         * Please note that all callbacks are done asynchronously; murmur does not wait for the callback to
         * complete before continuing processing.
         * Note that callbacks are removed when a server is stopped, so you should have a callback for
         * {@link MetaCallback.started} which calls {@link Server.addCallback}.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         * @see MetaCallback
         * @see Server.addCallback
         */
        abstract userDisconnected(state:User, current:iceNS0.Ice.Current):PromiseLike<void>|void;
        /**
         * Callback interface for servers. You can supply an implementation of this to receive notification
         * messages from the server.
         * If an added callback ever throws an exception or goes away, it will be automatically removed.
         * Please note that all callbacks are done asynchronously; murmur does not wait for the callback to
         * complete before continuing processing.
         * Note that callbacks are removed when a server is stopped, so you should have a callback for
         * {@link MetaCallback.started} which calls {@link Server.addCallback}.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         * @see MetaCallback
         * @see Server.addCallback
         */
        abstract userStateChanged(state:User, current:iceNS0.Ice.Current):PromiseLike<void>|void;
        /**
         * Callback interface for servers. You can supply an implementation of this to receive notification
         * messages from the server.
         * If an added callback ever throws an exception or goes away, it will be automatically removed.
         * Please note that all callbacks are done asynchronously; murmur does not wait for the callback to
         * complete before continuing processing.
         * Note that callbacks are removed when a server is stopped, so you should have a callback for
         * {@link MetaCallback.started} which calls {@link Server.addCallback}.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         * @see MetaCallback
         * @see Server.addCallback
         */
        abstract userTextMessage(state:User, message:TextMessage, current:iceNS0.Ice.Current):PromiseLike<void>|void;
        /**
         * Callback interface for servers. You can supply an implementation of this to receive notification
         * messages from the server.
         * If an added callback ever throws an exception or goes away, it will be automatically removed.
         * Please note that all callbacks are done asynchronously; murmur does not wait for the callback to
         * complete before continuing processing.
         * Note that callbacks are removed when a server is stopped, so you should have a callback for
         * {@link MetaCallback.started} which calls {@link Server.addCallback}.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         * @see MetaCallback
         * @see Server.addCallback
         */
        abstract channelCreated(state:Channel, current:iceNS0.Ice.Current):PromiseLike<void>|void;
        /**
         * Callback interface for servers. You can supply an implementation of this to receive notification
         * messages from the server.
         * If an added callback ever throws an exception or goes away, it will be automatically removed.
         * Please note that all callbacks are done asynchronously; murmur does not wait for the callback to
         * complete before continuing processing.
         * Note that callbacks are removed when a server is stopped, so you should have a callback for
         * {@link MetaCallback.started} which calls {@link Server.addCallback}.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         * @see MetaCallback
         * @see Server.addCallback
         */
        abstract channelRemoved(state:Channel, current:iceNS0.Ice.Current):PromiseLike<void>|void;
        /**
         * Callback interface for servers. You can supply an implementation of this to receive notification
         * messages from the server.
         * If an added callback ever throws an exception or goes away, it will be automatically removed.
         * Please note that all callbacks are done asynchronously; murmur does not wait for the callback to
         * complete before continuing processing.
         * Note that callbacks are removed when a server is stopped, so you should have a callback for
         * {@link MetaCallback.started} which calls {@link Server.addCallback}.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         * @see MetaCallback
         * @see Server.addCallback
         */
        abstract channelStateChanged(state:Channel, current:iceNS0.Ice.Current):PromiseLike<void>|void;
        /**
         * Obtains the Slice type ID of this type.
         * @return The return value is always "::Murmur::ServerCallback".
         */
        static ice_staticId():string;
    }

    /**
     * Context for actions in the Server menu.
     */
    const ContextServer:number;

    /**
     * Context for actions in the Channel menu.
     */
    const ContextChannel:number;

    /**
     * Context for actions in the User menu.
     */
    const ContextUser:number;

    abstract class ServerContextCallbackPrx extends iceNS0.Ice.ObjectPrx
    {
        /**
         * Called when a context action is performed.
         * @param action Action to be performed.
         * @param usr User which initiated the action.
         * @param session If nonzero, session of target user.
         * @param channelid If not -1, id of target channel.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        contextAction(action:string, usr:User, session:number, channelid:number, context?:Map<string, string>):iceNS0.Ice.AsyncResult<void>;

        /**
         * Downcasts a proxy without confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @return A proxy with the requested type.
         */
        static uncheckedCast(prx:iceNS0.Ice.ObjectPrx, facet?:string):ServerContextCallbackPrx;
        /**
         * Downcasts a proxy after confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @param facet A facet name.
         * @param context The context map for the invocation.
         * @return A proxy with the requested type and facet, or nil if the target proxy is nil or the target
         * object does not support the requested type.
         */
        static checkedCast(prx:iceNS0.Ice.ObjectPrx, facet?:string, contex?:Map<string, string>):iceNS0.Ice.AsyncResult<ServerContextCallbackPrx>;
    }

    abstract class ServerContextCallback extends iceNS0.Ice.Object
    {
        /**
         * Callback interface for context actions. You need to supply one of these for {@link Server.addContext}.
         * If an added callback ever throws an exception or goes away, it will be automatically removed.
         * Please note that all callbacks are done asynchronously; murmur does not wait for the callback to
         * complete before continuing processing.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract contextAction(action:string, usr:User, session:number, channelid:number, current:iceNS0.Ice.Current):PromiseLike<void>|void;
        /**
         * Obtains the Slice type ID of this type.
         * @return The return value is always "::Murmur::ServerContextCallback".
         */
        static ice_staticId():string;
    }

    abstract class ServerAuthenticatorPrx extends iceNS0.Ice.ObjectPrx
    {
        /**
         * Called to authenticate a user. If you do not know the username in question, always return -2 from this
         * method to fall through to normal database authentication.
         * Note that if authentication succeeds, murmur will create a record of the user in it's database, reserving
         * the username and id so it cannot be used for normal database authentication.
         * The data in the certificate (name, email addresses etc), as well as the list of signing certificates,
         * should only be trusted if certstrong is true.
         *
         * Internally, Murmur treats usernames as case-insensitive. It is recommended
         * that authenticators do the same. Murmur checks if a username is in use when
         * a user connects. If the connecting user is registered, the other username is
         * kicked. If the connecting user is not registered, the connecting user is not
         * allowed to join the server.
         * @param name Username to authenticate.
         * @param pw Password to authenticate with.
         * @param certificates List of der encoded certificates the user connected with.
         * @param certhash Hash of user certificate, as used by murmur internally when matching.
         * @param certstrong True if certificate was valid and signed by a trusted CA.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        authenticate(name:string, pw:string, certificates:CertificateList, certhash:string, certstrong:boolean, context?:Map<string, string>):iceNS0.Ice.AsyncResult<[number, string, GroupNameList]>;
        /**
         * Fetch information about a user. This is used to retrieve information like email address, keyhash etc. If you
         * want murmur to take care of this information itself, simply return false to fall through.
         * @param id User id.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        getInfo(id:number, context?:Map<string, string>):iceNS0.Ice.AsyncResult<[boolean, UserInfoMap]>;
        /**
         * Map a name to a user id.
         * @param name Username to map.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        nameToId(name:string, context?:Map<string, string>):iceNS0.Ice.AsyncResult<number>;
        /**
         * Map a user id to a username.
         * @param id User id to map.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        idToName(id:number, context?:Map<string, string>):iceNS0.Ice.AsyncResult<string>;
        /**
         * Map a user to a custom Texture.
         * @param id User id to map.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        idToTexture(id:number, context?:Map<string, string>):iceNS0.Ice.AsyncResult<Texture>;

        /**
         * Downcasts a proxy without confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @return A proxy with the requested type.
         */
        static uncheckedCast(prx:iceNS0.Ice.ObjectPrx, facet?:string):ServerAuthenticatorPrx;
        /**
         * Downcasts a proxy after confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @param facet A facet name.
         * @param context The context map for the invocation.
         * @return A proxy with the requested type and facet, or nil if the target proxy is nil or the target
         * object does not support the requested type.
         */
        static checkedCast(prx:iceNS0.Ice.ObjectPrx, facet?:string, contex?:Map<string, string>):iceNS0.Ice.AsyncResult<ServerAuthenticatorPrx>;
    }

    abstract class ServerAuthenticator extends iceNS0.Ice.Object
    {
        /**
         * Callback interface for server authentication. You need to supply one of these for {@link Server.setAuthenticator}.
         * If an added callback ever throws an exception or goes away, it will be automatically removed.
         * Please note that unlike {@link ServerCallback} and {@link ServerContextCallback}, these methods are called
         * synchronously. If the response lags, the entire murmur server will lag.
         * Also note that, as the method calls are synchronous, making a call to {@link Server} or {@link Meta} will
         * deadlock the server.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract authenticate(name:string, pw:string, certificates:CertificateList, certhash:string, certstrong:boolean, current:iceNS0.Ice.Current):PromiseLike<[number, string, GroupNameList]>|[number, string, GroupNameList];
        /**
         * Callback interface for server authentication. You need to supply one of these for {@link Server.setAuthenticator}.
         * If an added callback ever throws an exception or goes away, it will be automatically removed.
         * Please note that unlike {@link ServerCallback} and {@link ServerContextCallback}, these methods are called
         * synchronously. If the response lags, the entire murmur server will lag.
         * Also note that, as the method calls are synchronous, making a call to {@link Server} or {@link Meta} will
         * deadlock the server.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract getInfo(id:number, current:iceNS0.Ice.Current):PromiseLike<[boolean, UserInfoMap]>|[boolean, UserInfoMap];
        /**
         * Callback interface for server authentication. You need to supply one of these for {@link Server.setAuthenticator}.
         * If an added callback ever throws an exception or goes away, it will be automatically removed.
         * Please note that unlike {@link ServerCallback} and {@link ServerContextCallback}, these methods are called
         * synchronously. If the response lags, the entire murmur server will lag.
         * Also note that, as the method calls are synchronous, making a call to {@link Server} or {@link Meta} will
         * deadlock the server.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract nameToId(name:string, current:iceNS0.Ice.Current):PromiseLike<number>|number;
        /**
         * Callback interface for server authentication. You need to supply one of these for {@link Server.setAuthenticator}.
         * If an added callback ever throws an exception or goes away, it will be automatically removed.
         * Please note that unlike {@link ServerCallback} and {@link ServerContextCallback}, these methods are called
         * synchronously. If the response lags, the entire murmur server will lag.
         * Also note that, as the method calls are synchronous, making a call to {@link Server} or {@link Meta} will
         * deadlock the server.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract idToName(id:number, current:iceNS0.Ice.Current):PromiseLike<string>|string;
        /**
         * Callback interface for server authentication. You need to supply one of these for {@link Server.setAuthenticator}.
         * If an added callback ever throws an exception or goes away, it will be automatically removed.
         * Please note that unlike {@link ServerCallback} and {@link ServerContextCallback}, these methods are called
         * synchronously. If the response lags, the entire murmur server will lag.
         * Also note that, as the method calls are synchronous, making a call to {@link Server} or {@link Meta} will
         * deadlock the server.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract idToTexture(id:number, current:iceNS0.Ice.Current):PromiseLike<Texture>|Texture;
        /**
         * Obtains the Slice type ID of this type.
         * @return The return value is always "::Murmur::ServerAuthenticator".
         */
        static ice_staticId():string;
    }

    abstract class ServerUpdatingAuthenticatorPrx extends iceNS0.Ice.ObjectPrx
    {
        /**
         * Called to authenticate a user. If you do not know the username in question, always return -2 from this
         * method to fall through to normal database authentication.
         * Note that if authentication succeeds, murmur will create a record of the user in it's database, reserving
         * the username and id so it cannot be used for normal database authentication.
         * The data in the certificate (name, email addresses etc), as well as the list of signing certificates,
         * should only be trusted if certstrong is true.
         *
         * Internally, Murmur treats usernames as case-insensitive. It is recommended
         * that authenticators do the same. Murmur checks if a username is in use when
         * a user connects. If the connecting user is registered, the other username is
         * kicked. If the connecting user is not registered, the connecting user is not
         * allowed to join the server.
         * @param name Username to authenticate.
         * @param pw Password to authenticate with.
         * @param certificates List of der encoded certificates the user connected with.
         * @param certhash Hash of user certificate, as used by murmur internally when matching.
         * @param certstrong True if certificate was valid and signed by a trusted CA.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        authenticate(name:string, pw:string, certificates:CertificateList, certhash:string, certstrong:boolean, context?:Map<string, string>):iceNS0.Ice.AsyncResult<[number, string, GroupNameList]>;
        /**
         * Fetch information about a user. This is used to retrieve information like email address, keyhash etc. If you
         * want murmur to take care of this information itself, simply return false to fall through.
         * @param id User id.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        getInfo(id:number, context?:Map<string, string>):iceNS0.Ice.AsyncResult<[boolean, UserInfoMap]>;
        /**
         * Map a name to a user id.
         * @param name Username to map.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        nameToId(name:string, context?:Map<string, string>):iceNS0.Ice.AsyncResult<number>;
        /**
         * Map a user id to a username.
         * @param id User id to map.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        idToName(id:number, context?:Map<string, string>):iceNS0.Ice.AsyncResult<string>;
        /**
         * Map a user to a custom Texture.
         * @param id User id to map.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        idToTexture(id:number, context?:Map<string, string>):iceNS0.Ice.AsyncResult<Texture>;
        /**
         * Register a new user.
         * @param info Information about user to register.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        registerUser(info:UserInfoMap, context?:Map<string, string>):iceNS0.Ice.AsyncResult<number>;
        /**
         * Unregister a user.
         * @param id Userid to unregister.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        unregisterUser(id:number, context?:Map<string, string>):iceNS0.Ice.AsyncResult<number>;
        /**
         * Get a list of registered users matching filter.
         * @param filter Substring usernames must contain. If empty, return all registered users.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        getRegisteredUsers(filter:string, context?:Map<string, string>):iceNS0.Ice.AsyncResult<NameMap>;
        /**
         * Set additional information for user registration.
         * @param id Userid of registered user.
         * @param info Information to set about user. This should be merged with existing information.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        setInfo(id:number, info:UserInfoMap, context?:Map<string, string>):iceNS0.Ice.AsyncResult<number>;
        /**
         * Set texture (now called avatar) of user registration.
         * @param id registrationId of registered user.
         * @param tex New texture.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        setTexture(id:number, tex:Texture, context?:Map<string, string>):iceNS0.Ice.AsyncResult<number>;

        /**
         * Downcasts a proxy without confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @return A proxy with the requested type.
         */
        static uncheckedCast(prx:iceNS0.Ice.ObjectPrx, facet?:string):ServerUpdatingAuthenticatorPrx;
        /**
         * Downcasts a proxy after confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @param facet A facet name.
         * @param context The context map for the invocation.
         * @return A proxy with the requested type and facet, or nil if the target proxy is nil or the target
         * object does not support the requested type.
         */
        static checkedCast(prx:iceNS0.Ice.ObjectPrx, facet?:string, contex?:Map<string, string>):iceNS0.Ice.AsyncResult<ServerUpdatingAuthenticatorPrx>;
    }

    abstract class ServerUpdatingAuthenticator extends iceNS0.Ice.Object
    {
        /**
         * Callback interface for server authentication and registration. This allows you to support both authentication
         * and account updating.
         * You do not need to implement this if all you want is authentication, you only need this if other scripts
         * connected to the same server calls e.g. {@link Server.setTexture}.
         * Almost all of these methods support fall through, meaning murmur should continue the operation against its
         * own database.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract authenticate(name:string, pw:string, certificates:CertificateList, certhash:string, certstrong:boolean, current:iceNS0.Ice.Current):PromiseLike<[number, string, GroupNameList]>|[number, string, GroupNameList];
        /**
         * Callback interface for server authentication and registration. This allows you to support both authentication
         * and account updating.
         * You do not need to implement this if all you want is authentication, you only need this if other scripts
         * connected to the same server calls e.g. {@link Server.setTexture}.
         * Almost all of these methods support fall through, meaning murmur should continue the operation against its
         * own database.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract getInfo(id:number, current:iceNS0.Ice.Current):PromiseLike<[boolean, UserInfoMap]>|[boolean, UserInfoMap];
        /**
         * Callback interface for server authentication and registration. This allows you to support both authentication
         * and account updating.
         * You do not need to implement this if all you want is authentication, you only need this if other scripts
         * connected to the same server calls e.g. {@link Server.setTexture}.
         * Almost all of these methods support fall through, meaning murmur should continue the operation against its
         * own database.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract nameToId(name:string, current:iceNS0.Ice.Current):PromiseLike<number>|number;
        /**
         * Callback interface for server authentication and registration. This allows you to support both authentication
         * and account updating.
         * You do not need to implement this if all you want is authentication, you only need this if other scripts
         * connected to the same server calls e.g. {@link Server.setTexture}.
         * Almost all of these methods support fall through, meaning murmur should continue the operation against its
         * own database.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract idToName(id:number, current:iceNS0.Ice.Current):PromiseLike<string>|string;
        /**
         * Callback interface for server authentication and registration. This allows you to support both authentication
         * and account updating.
         * You do not need to implement this if all you want is authentication, you only need this if other scripts
         * connected to the same server calls e.g. {@link Server.setTexture}.
         * Almost all of these methods support fall through, meaning murmur should continue the operation against its
         * own database.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract idToTexture(id:number, current:iceNS0.Ice.Current):PromiseLike<Texture>|Texture;
        /**
         * Callback interface for server authentication and registration. This allows you to support both authentication
         * and account updating.
         * You do not need to implement this if all you want is authentication, you only need this if other scripts
         * connected to the same server calls e.g. {@link Server.setTexture}.
         * Almost all of these methods support fall through, meaning murmur should continue the operation against its
         * own database.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract registerUser(info:UserInfoMap, current:iceNS0.Ice.Current):PromiseLike<number>|number;
        /**
         * Callback interface for server authentication and registration. This allows you to support both authentication
         * and account updating.
         * You do not need to implement this if all you want is authentication, you only need this if other scripts
         * connected to the same server calls e.g. {@link Server.setTexture}.
         * Almost all of these methods support fall through, meaning murmur should continue the operation against its
         * own database.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract unregisterUser(id:number, current:iceNS0.Ice.Current):PromiseLike<number>|number;
        /**
         * Callback interface for server authentication and registration. This allows you to support both authentication
         * and account updating.
         * You do not need to implement this if all you want is authentication, you only need this if other scripts
         * connected to the same server calls e.g. {@link Server.setTexture}.
         * Almost all of these methods support fall through, meaning murmur should continue the operation against its
         * own database.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract getRegisteredUsers(filter:string, current:iceNS0.Ice.Current):PromiseLike<NameMap>|NameMap;
        /**
         * Callback interface for server authentication and registration. This allows you to support both authentication
         * and account updating.
         * You do not need to implement this if all you want is authentication, you only need this if other scripts
         * connected to the same server calls e.g. {@link Server.setTexture}.
         * Almost all of these methods support fall through, meaning murmur should continue the operation against its
         * own database.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract setInfo(id:number, info:UserInfoMap, current:iceNS0.Ice.Current):PromiseLike<number>|number;
        /**
         * Callback interface for server authentication and registration. This allows you to support both authentication
         * and account updating.
         * You do not need to implement this if all you want is authentication, you only need this if other scripts
         * connected to the same server calls e.g. {@link Server.setTexture}.
         * Almost all of these methods support fall through, meaning murmur should continue the operation against its
         * own database.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract setTexture(id:number, tex:Texture, current:iceNS0.Ice.Current):PromiseLike<number>|number;
        /**
         * Obtains the Slice type ID of this type.
         * @return The return value is always "::Murmur::ServerUpdatingAuthenticator".
         */
        static ice_staticId():string;
    }

    abstract class ServerPrx extends iceNS0.Ice.ObjectPrx
    {
        /**
         * Shows if the server currently running (accepting users).
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        isRunning(context?:Map<string, string>):iceNS0.Ice.AsyncResult<boolean>;
        /**
         * Start server.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        start(context?:Map<string, string>):iceNS0.Ice.AsyncResult<void>;
        /**
         * Stop server.
         * Note: Server will be restarted on Murmur restart unless explicitly disabled
         * with setConf("boot", false)
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        stop(context?:Map<string, string>):iceNS0.Ice.AsyncResult<void>;
        /**
         * Delete server and all it's configuration.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        _delete(context?:Map<string, string>):iceNS0.Ice.AsyncResult<void>;
        /**
         * Fetch the server id.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        id(context?:Map<string, string>):iceNS0.Ice.AsyncResult<number>;
        /**
         * Add a callback. The callback will receive notifications about changes to users and channels.
         * @param cb Callback interface which will receive notifications.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         * @see removeCallback
         */
        addCallback(cb:ServerCallbackPrx, context?:Map<string, string>):iceNS0.Ice.AsyncResult<void>;
        /**
         * Remove a callback.
         * @param cb Callback interface to be removed.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         * @see addCallback
         */
        removeCallback(cb:ServerCallbackPrx, context?:Map<string, string>):iceNS0.Ice.AsyncResult<void>;
        /**
         * Set external authenticator. If set, all authentications from clients are forwarded to this
         * proxy.
         * @param auth Authenticator object to perform subsequent authentications.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        setAuthenticator(auth:ServerAuthenticatorPrx, context?:Map<string, string>):iceNS0.Ice.AsyncResult<void>;
        /**
         * Retrieve configuration item.
         * @param key Configuration key.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        getConf(key:string, context?:Map<string, string>):iceNS0.Ice.AsyncResult<string>;
        /**
         * Retrieve all configuration items.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        getAllConf(context?:Map<string, string>):iceNS0.Ice.AsyncResult<ConfigMap>;
        /**
         * Set a configuration item.
         * @param key Configuration key.
         * @param value Configuration value.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        setConf(key:string, value:string, context?:Map<string, string>):iceNS0.Ice.AsyncResult<void>;
        /**
         * Set superuser password. This is just a convenience for using {@link updateRegistration} on user id 0.
         * @param pw Password.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        setSuperuserPassword(pw:string, context?:Map<string, string>):iceNS0.Ice.AsyncResult<void>;
        /**
         * Fetch log entries.
         * @param first Lowest numbered entry to fetch. 0 is the most recent item.
         * @param last Last entry to fetch.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        getLog(first:number, last:number, context?:Map<string, string>):iceNS0.Ice.AsyncResult<LogList>;
        /**
         * Fetch length of log
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        getLogLen(context?:Map<string, string>):iceNS0.Ice.AsyncResult<number>;
        /**
         * Fetch all users. This returns all currently connected users on the server.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         * @see getState
         */
        getUsers(context?:Map<string, string>):iceNS0.Ice.AsyncResult<UserMap>;
        /**
         * Fetch all channels. This returns all defined channels on the server. The root channel is always channel 0.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         * @see getChannelState
         */
        getChannels(context?:Map<string, string>):iceNS0.Ice.AsyncResult<ChannelMap>;
        /**
         * Fetch certificate of user. This returns the complete certificate chain of a user.
         * @param session Connection ID of user. See {@link User.session}.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        getCertificateList(session:number, context?:Map<string, string>):iceNS0.Ice.AsyncResult<CertificateList>;
        /**
         * Fetch all channels and connected users as a tree. This retrieves an easy-to-use representation of the server
         * as a tree. This is primarily used for viewing the state of the server on a webpage.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        getTree(context?:Map<string, string>):iceNS0.Ice.AsyncResult<Murmur.Tree>;
        /**
         * Fetch all current IP bans on the server.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        getBans(context?:Map<string, string>):iceNS0.Ice.AsyncResult<BanList>;
        /**
         * Set all current IP bans on the server. This will replace any bans already present, so if you want to add a ban, be sure to call {@link getBans} and then
         * append to the returned list before calling this method.
         * @param bans List of bans.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        setBans(bans:BanList, context?:Map<string, string>):iceNS0.Ice.AsyncResult<void>;
        /**
         * Kick a user. The user is not banned, and is free to rejoin the server.
         * @param session Connection ID of user. See {@link User.session}.
         * @param reason Text message to show when user is kicked.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        kickUser(session:number, reason:string, context?:Map<string, string>):iceNS0.Ice.AsyncResult<void>;
        /**
         * Get state of a single connected user.
         * @param session Connection ID of user. See {@link User.session}.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         * @see setState
         * @see getUsers
         */
        getState(session:number, context?:Map<string, string>):iceNS0.Ice.AsyncResult<User>;
        /**
         * Set user state. You can use this to move, mute and deafen users.
         * @param state User state to set.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         * @see getState
         */
        setState(state:User, context?:Map<string, string>):iceNS0.Ice.AsyncResult<void>;
        /**
         * Send text message to a single user.
         * @param session Connection ID of user. See {@link User.session}.
         * @param text Message to send.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         * @see sendMessageChannel
         */
        sendMessage(session:number, text:string, context?:Map<string, string>):iceNS0.Ice.AsyncResult<void>;
        /**
         * Check if user is permitted to perform action.
         * @param session Connection ID of user. See {@link User.session}.
         * @param channelid ID of Channel. See {@link Channel.id}.
         * @param perm Permission bits to check.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        hasPermission(session:number, channelid:number, perm:number, context?:Map<string, string>):iceNS0.Ice.AsyncResult<boolean>;
        /**
         * Return users effective permissions
         * @param session Connection ID of user. See {@link User.session}.
         * @param channelid ID of Channel. See {@link Channel.id}.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        effectivePermissions(session:number, channelid:number, context?:Map<string, string>):iceNS0.Ice.AsyncResult<number>;
        /**
         * Add a context callback. This is done per user, and will add a context menu action for the user.
         * @param session Session of user which should receive context entry.
         * @param action Action string, a unique name to associate with the action.
         * @param text Name of action shown to user.
         * @param cb Callback interface which will receive notifications.
         * @param ctx Context this should be used in. Needs to be one or a combination of {@link ContextServer}, {@link ContextChannel} and {@link ContextUser}.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         * @see removeContextCallback
         */
        addContextCallback(session:number, action:string, text:string, cb:ServerContextCallbackPrx, ctx:number, context?:Map<string, string>):iceNS0.Ice.AsyncResult<void>;
        /**
         * Remove a callback.
         * @param cb Callback interface to be removed. This callback will be removed from all from all users.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         * @see addContextCallback
         */
        removeContextCallback(cb:ServerContextCallbackPrx, context?:Map<string, string>):iceNS0.Ice.AsyncResult<void>;
        /**
         * Get state of single channel.
         * @param channelid ID of Channel. See {@link Channel.id}.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         * @see setChannelState
         * @see getChannels
         */
        getChannelState(channelid:number, context?:Map<string, string>):iceNS0.Ice.AsyncResult<Channel>;
        /**
         * Set state of a single channel. You can use this to move or relink channels.
         * @param state Channel state to set.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         * @see getChannelState
         */
        setChannelState(state:Channel, context?:Map<string, string>):iceNS0.Ice.AsyncResult<void>;
        /**
         * Remove a channel and all its subchannels.
         * @param channelid ID of Channel. See {@link Channel.id}.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        removeChannel(channelid:number, context?:Map<string, string>):iceNS0.Ice.AsyncResult<void>;
        /**
         * Add a new channel.
         * @param name Name of new channel.
         * @param parent Channel ID of parent channel. See {@link Channel.id}.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        addChannel(name:string, parent:number, context?:Map<string, string>):iceNS0.Ice.AsyncResult<number>;
        /**
         * Send text message to channel or a tree of channels.
         * @param channelid Channel ID of channel to send to. See {@link Channel.id}.
         * @param tree If true, the message will be sent to the channel and all its subchannels.
         * @param text Message to send.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         * @see sendMessage
         */
        sendMessageChannel(channelid:number, tree:boolean, text:string, context?:Map<string, string>):iceNS0.Ice.AsyncResult<void>;
        /**
         * Retrieve ACLs and Groups on a channel.
         * @param channelid Channel ID of channel to fetch from. See {@link Channel.id}.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        getACL(channelid:number, context?:Map<string, string>):iceNS0.Ice.AsyncResult<[ACLList, GroupList, boolean]>;
        /**
         * Set ACLs and Groups on a channel. Note that this will replace all existing ACLs and groups on the channel.
         * @param channelid Channel ID of channel to fetch from. See {@link Channel.id}.
         * @param acls List of ACLs on the channel.
         * @param groups List of groups on the channel.
         * @param inherit Should this channel inherit ACLs from the parent channel?
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        setACL(channelid:number, acls:ACLList, groups:GroupList, inherit:boolean, context?:Map<string, string>):iceNS0.Ice.AsyncResult<void>;
        /**
         * Temporarily add a user to a group on a channel. This state is not saved, and is intended for temporary memberships.
         * @param channelid Channel ID of channel to add to. See {@link Channel.id}.
         * @param session Connection ID of user. See {@link User.session}.
         * @param group Group name to add to.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        addUserToGroup(channelid:number, session:number, group:string, context?:Map<string, string>):iceNS0.Ice.AsyncResult<void>;
        /**
         * Remove a user from a temporary group membership on a channel. This state is not saved, and is intended for temporary memberships.
         * @param channelid Channel ID of channel to add to. See {@link Channel.id}.
         * @param session Connection ID of user. See {@link User.session}.
         * @param group Group name to remove from.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        removeUserFromGroup(channelid:number, session:number, group:string, context?:Map<string, string>):iceNS0.Ice.AsyncResult<void>;
        /**
         * Redirect whisper targets for user. If set, whenever a user tries to whisper to group "source", the whisper will be redirected to group "target".
         * To remove a redirect pass an empty target string. This is intended for context groups.
         * @param session Connection ID of user. See {@link User.session}.
         * @param source Group name to redirect from.
         * @param target Group name to redirect to.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        redirectWhisperGroup(session:number, source:string, target:string, context?:Map<string, string>):iceNS0.Ice.AsyncResult<void>;
        /**
         * Map a list of {@link User.userid} to a matching name.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        getUserNames(ids:IdList, context?:Map<string, string>):iceNS0.Ice.AsyncResult<NameMap>;
        /**
         * Map a list of user names to a matching id.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         * @reuturn List of matching ids, with -1 representing invalid or unknown user names.
         */
        getUserIds(names:NameList, context?:Map<string, string>):iceNS0.Ice.AsyncResult<IdMap>;
        /**
         * Register a new user.
         * @param info Information about new user. Must include at least "name".
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        registerUser(info:UserInfoMap, context?:Map<string, string>):iceNS0.Ice.AsyncResult<number>;
        /**
         * Remove a user registration.
         * @param userid ID of registered user. See {@link RegisteredUser.userid}.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        unregisterUser(userid:number, context?:Map<string, string>):iceNS0.Ice.AsyncResult<void>;
        /**
         * Update the registration for a user. You can use this to set the email or password of a user,
         * and can also use it to change the user's name.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        updateRegistration(userid:number, info:UserInfoMap, context?:Map<string, string>):iceNS0.Ice.AsyncResult<void>;
        /**
         * Fetch registration for a single user.
         * @param userid ID of registered user. See {@link RegisteredUser.userid}.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        getRegistration(userid:number, context?:Map<string, string>):iceNS0.Ice.AsyncResult<UserInfoMap>;
        /**
         * Fetch a group of registered users.
         * @param filter Substring of user name. If blank, will retrieve all registered users.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        getRegisteredUsers(filter:string, context?:Map<string, string>):iceNS0.Ice.AsyncResult<NameMap>;
        /**
         * Verify the password of a user. You can use this to verify a user's credentials.
         * @param name User name. See {@link RegisteredUser.name}.
         * @param pw User password.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        verifyPassword(name:string, pw:string, context?:Map<string, string>):iceNS0.Ice.AsyncResult<number>;
        /**
         * Fetch user texture. Textures are stored as zlib compress()ed 600x60 32-bit BGRA data.
         * @param userid ID of registered user. See {@link RegisteredUser.userid}.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        getTexture(userid:number, context?:Map<string, string>):iceNS0.Ice.AsyncResult<Texture>;
        /**
         * Set a user texture (now called avatar).
         * @param userid ID of registered user. See {@link RegisteredUser.userid}.
         * @param tex Texture (as a Byte-Array) to set for the user, or an empty texture to remove the existing texture.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        setTexture(userid:number, tex:Texture, context?:Map<string, string>):iceNS0.Ice.AsyncResult<void>;
        /**
         * Get virtual server uptime.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        getUptime(context?:Map<string, string>):iceNS0.Ice.AsyncResult<number>;
        /**
         * Update the server's certificate information.
         *
         * Reconfigure the running server's TLS socket with the given
         * certificate and private key.
         *
         * The certificate and and private key must be PEM formatted.
         *
         * New clients will see the new certificate.
         * Existing clients will continue to see the certificate the server
         * was using when they connected to it.
         *
         * This method throws InvalidInputDataException if any of the
         * following errors happen:
         * - Unable to decode the PEM certificate and/or private key.
         * - Unable to decrypt the private key with the given passphrase.
         * - The certificate and/or private key do not contain RSA keys.
         * - The certificate is not usable with the given private key.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        updateCertificate(certificate:string, privateKey:string, passphrase:string, context?:Map<string, string>):iceNS0.Ice.AsyncResult<void>;

        /**
         * Downcasts a proxy without confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @return A proxy with the requested type.
         */
        static uncheckedCast(prx:iceNS0.Ice.ObjectPrx, facet?:string):ServerPrx;
        /**
         * Downcasts a proxy after confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @param facet A facet name.
         * @param context The context map for the invocation.
         * @return A proxy with the requested type and facet, or nil if the target proxy is nil or the target
         * object does not support the requested type.
         */
        static checkedCast(prx:iceNS0.Ice.ObjectPrx, facet?:string, contex?:Map<string, string>):iceNS0.Ice.AsyncResult<ServerPrx>;
    }

    abstract class Server extends iceNS0.Ice.Object
    {
        /**
         * Per-server interface. This includes all methods for configuring and altering
         * the state of a single virtual server. You can retrieve a pointer to this interface
         * from one of the methods in {@link Meta}.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract isRunning(current:iceNS0.Ice.Current):PromiseLike<boolean>|boolean;
        /**
         * Per-server interface. This includes all methods for configuring and altering
         * the state of a single virtual server. You can retrieve a pointer to this interface
         * from one of the methods in {@link Meta}.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract start(current:iceNS0.Ice.Current):PromiseLike<void>|void;
        /**
         * Per-server interface. This includes all methods for configuring and altering
         * the state of a single virtual server. You can retrieve a pointer to this interface
         * from one of the methods in {@link Meta}.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract stop(current:iceNS0.Ice.Current):PromiseLike<void>|void;
        /**
         * Per-server interface. This includes all methods for configuring and altering
         * the state of a single virtual server. You can retrieve a pointer to this interface
         * from one of the methods in {@link Meta}.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract _delete(current:iceNS0.Ice.Current):PromiseLike<void>|void;
        /**
         * Per-server interface. This includes all methods for configuring and altering
         * the state of a single virtual server. You can retrieve a pointer to this interface
         * from one of the methods in {@link Meta}.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract id(current:iceNS0.Ice.Current):PromiseLike<number>|number;
        /**
         * Per-server interface. This includes all methods for configuring and altering
         * the state of a single virtual server. You can retrieve a pointer to this interface
         * from one of the methods in {@link Meta}.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract addCallback(cb:ServerCallbackPrx, current:iceNS0.Ice.Current):PromiseLike<void>|void;
        /**
         * Per-server interface. This includes all methods for configuring and altering
         * the state of a single virtual server. You can retrieve a pointer to this interface
         * from one of the methods in {@link Meta}.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract removeCallback(cb:ServerCallbackPrx, current:iceNS0.Ice.Current):PromiseLike<void>|void;
        /**
         * Per-server interface. This includes all methods for configuring and altering
         * the state of a single virtual server. You can retrieve a pointer to this interface
         * from one of the methods in {@link Meta}.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract setAuthenticator(auth:ServerAuthenticatorPrx, current:iceNS0.Ice.Current):PromiseLike<void>|void;
        /**
         * Per-server interface. This includes all methods for configuring and altering
         * the state of a single virtual server. You can retrieve a pointer to this interface
         * from one of the methods in {@link Meta}.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract getConf(key:string, current:iceNS0.Ice.Current):PromiseLike<string>|string;
        /**
         * Per-server interface. This includes all methods for configuring and altering
         * the state of a single virtual server. You can retrieve a pointer to this interface
         * from one of the methods in {@link Meta}.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract getAllConf(current:iceNS0.Ice.Current):PromiseLike<ConfigMap>|ConfigMap;
        /**
         * Per-server interface. This includes all methods for configuring and altering
         * the state of a single virtual server. You can retrieve a pointer to this interface
         * from one of the methods in {@link Meta}.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract setConf(key:string, value:string, current:iceNS0.Ice.Current):PromiseLike<void>|void;
        /**
         * Per-server interface. This includes all methods for configuring and altering
         * the state of a single virtual server. You can retrieve a pointer to this interface
         * from one of the methods in {@link Meta}.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract setSuperuserPassword(pw:string, current:iceNS0.Ice.Current):PromiseLike<void>|void;
        /**
         * Per-server interface. This includes all methods for configuring and altering
         * the state of a single virtual server. You can retrieve a pointer to this interface
         * from one of the methods in {@link Meta}.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract getLog(first:number, last:number, current:iceNS0.Ice.Current):PromiseLike<LogList>|LogList;
        /**
         * Per-server interface. This includes all methods for configuring and altering
         * the state of a single virtual server. You can retrieve a pointer to this interface
         * from one of the methods in {@link Meta}.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract getLogLen(current:iceNS0.Ice.Current):PromiseLike<number>|number;
        /**
         * Per-server interface. This includes all methods for configuring and altering
         * the state of a single virtual server. You can retrieve a pointer to this interface
         * from one of the methods in {@link Meta}.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract getUsers(current:iceNS0.Ice.Current):PromiseLike<UserMap>|UserMap;
        /**
         * Per-server interface. This includes all methods for configuring and altering
         * the state of a single virtual server. You can retrieve a pointer to this interface
         * from one of the methods in {@link Meta}.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract getChannels(current:iceNS0.Ice.Current):PromiseLike<ChannelMap>|ChannelMap;
        /**
         * Per-server interface. This includes all methods for configuring and altering
         * the state of a single virtual server. You can retrieve a pointer to this interface
         * from one of the methods in {@link Meta}.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract getCertificateList(session:number, current:iceNS0.Ice.Current):PromiseLike<CertificateList>|CertificateList;
        /**
         * Per-server interface. This includes all methods for configuring and altering
         * the state of a single virtual server. You can retrieve a pointer to this interface
         * from one of the methods in {@link Meta}.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract getTree(current:iceNS0.Ice.Current):PromiseLike<Murmur.Tree>|Murmur.Tree;
        /**
         * Per-server interface. This includes all methods for configuring and altering
         * the state of a single virtual server. You can retrieve a pointer to this interface
         * from one of the methods in {@link Meta}.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract getBans(current:iceNS0.Ice.Current):PromiseLike<BanList>|BanList;
        /**
         * Per-server interface. This includes all methods for configuring and altering
         * the state of a single virtual server. You can retrieve a pointer to this interface
         * from one of the methods in {@link Meta}.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract setBans(bans:BanList, current:iceNS0.Ice.Current):PromiseLike<void>|void;
        /**
         * Per-server interface. This includes all methods for configuring and altering
         * the state of a single virtual server. You can retrieve a pointer to this interface
         * from one of the methods in {@link Meta}.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract kickUser(session:number, reason:string, current:iceNS0.Ice.Current):PromiseLike<void>|void;
        /**
         * Per-server interface. This includes all methods for configuring and altering
         * the state of a single virtual server. You can retrieve a pointer to this interface
         * from one of the methods in {@link Meta}.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract getState(session:number, current:iceNS0.Ice.Current):PromiseLike<User>|User;
        /**
         * Per-server interface. This includes all methods for configuring and altering
         * the state of a single virtual server. You can retrieve a pointer to this interface
         * from one of the methods in {@link Meta}.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract setState(state:User, current:iceNS0.Ice.Current):PromiseLike<void>|void;
        /**
         * Per-server interface. This includes all methods for configuring and altering
         * the state of a single virtual server. You can retrieve a pointer to this interface
         * from one of the methods in {@link Meta}.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract sendMessage(session:number, text:string, current:iceNS0.Ice.Current):PromiseLike<void>|void;
        /**
         * Per-server interface. This includes all methods for configuring and altering
         * the state of a single virtual server. You can retrieve a pointer to this interface
         * from one of the methods in {@link Meta}.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract hasPermission(session:number, channelid:number, perm:number, current:iceNS0.Ice.Current):PromiseLike<boolean>|boolean;
        /**
         * Per-server interface. This includes all methods for configuring and altering
         * the state of a single virtual server. You can retrieve a pointer to this interface
         * from one of the methods in {@link Meta}.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract effectivePermissions(session:number, channelid:number, current:iceNS0.Ice.Current):PromiseLike<number>|number;
        /**
         * Per-server interface. This includes all methods for configuring and altering
         * the state of a single virtual server. You can retrieve a pointer to this interface
         * from one of the methods in {@link Meta}.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract addContextCallback(session:number, action:string, text:string, cb:ServerContextCallbackPrx, ctx:number, current:iceNS0.Ice.Current):PromiseLike<void>|void;
        /**
         * Per-server interface. This includes all methods for configuring and altering
         * the state of a single virtual server. You can retrieve a pointer to this interface
         * from one of the methods in {@link Meta}.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract removeContextCallback(cb:ServerContextCallbackPrx, current:iceNS0.Ice.Current):PromiseLike<void>|void;
        /**
         * Per-server interface. This includes all methods for configuring and altering
         * the state of a single virtual server. You can retrieve a pointer to this interface
         * from one of the methods in {@link Meta}.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract getChannelState(channelid:number, current:iceNS0.Ice.Current):PromiseLike<Channel>|Channel;
        /**
         * Per-server interface. This includes all methods for configuring and altering
         * the state of a single virtual server. You can retrieve a pointer to this interface
         * from one of the methods in {@link Meta}.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract setChannelState(state:Channel, current:iceNS0.Ice.Current):PromiseLike<void>|void;
        /**
         * Per-server interface. This includes all methods for configuring and altering
         * the state of a single virtual server. You can retrieve a pointer to this interface
         * from one of the methods in {@link Meta}.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract removeChannel(channelid:number, current:iceNS0.Ice.Current):PromiseLike<void>|void;
        /**
         * Per-server interface. This includes all methods for configuring and altering
         * the state of a single virtual server. You can retrieve a pointer to this interface
         * from one of the methods in {@link Meta}.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract addChannel(name:string, parent:number, current:iceNS0.Ice.Current):PromiseLike<number>|number;
        /**
         * Per-server interface. This includes all methods for configuring and altering
         * the state of a single virtual server. You can retrieve a pointer to this interface
         * from one of the methods in {@link Meta}.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract sendMessageChannel(channelid:number, tree:boolean, text:string, current:iceNS0.Ice.Current):PromiseLike<void>|void;
        /**
         * Per-server interface. This includes all methods for configuring and altering
         * the state of a single virtual server. You can retrieve a pointer to this interface
         * from one of the methods in {@link Meta}.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract getACL(channelid:number, current:iceNS0.Ice.Current):PromiseLike<[ACLList, GroupList, boolean]>|[ACLList, GroupList, boolean];
        /**
         * Per-server interface. This includes all methods for configuring and altering
         * the state of a single virtual server. You can retrieve a pointer to this interface
         * from one of the methods in {@link Meta}.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract setACL(channelid:number, acls:ACLList, groups:GroupList, inherit:boolean, current:iceNS0.Ice.Current):PromiseLike<void>|void;
        /**
         * Per-server interface. This includes all methods for configuring and altering
         * the state of a single virtual server. You can retrieve a pointer to this interface
         * from one of the methods in {@link Meta}.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract addUserToGroup(channelid:number, session:number, group:string, current:iceNS0.Ice.Current):PromiseLike<void>|void;
        /**
         * Per-server interface. This includes all methods for configuring and altering
         * the state of a single virtual server. You can retrieve a pointer to this interface
         * from one of the methods in {@link Meta}.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract removeUserFromGroup(channelid:number, session:number, group:string, current:iceNS0.Ice.Current):PromiseLike<void>|void;
        /**
         * Per-server interface. This includes all methods for configuring and altering
         * the state of a single virtual server. You can retrieve a pointer to this interface
         * from one of the methods in {@link Meta}.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract redirectWhisperGroup(session:number, source:string, target:string, current:iceNS0.Ice.Current):PromiseLike<void>|void;
        /**
         * Per-server interface. This includes all methods for configuring and altering
         * the state of a single virtual server. You can retrieve a pointer to this interface
         * from one of the methods in {@link Meta}.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract getUserNames(ids:IdList, current:iceNS0.Ice.Current):PromiseLike<NameMap>|NameMap;
        /**
         * Per-server interface. This includes all methods for configuring and altering
         * the state of a single virtual server. You can retrieve a pointer to this interface
         * from one of the methods in {@link Meta}.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract getUserIds(names:NameList, current:iceNS0.Ice.Current):PromiseLike<IdMap>|IdMap;
        /**
         * Per-server interface. This includes all methods for configuring and altering
         * the state of a single virtual server. You can retrieve a pointer to this interface
         * from one of the methods in {@link Meta}.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract registerUser(info:UserInfoMap, current:iceNS0.Ice.Current):PromiseLike<number>|number;
        /**
         * Per-server interface. This includes all methods for configuring and altering
         * the state of a single virtual server. You can retrieve a pointer to this interface
         * from one of the methods in {@link Meta}.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract unregisterUser(userid:number, current:iceNS0.Ice.Current):PromiseLike<void>|void;
        /**
         * Per-server interface. This includes all methods for configuring and altering
         * the state of a single virtual server. You can retrieve a pointer to this interface
         * from one of the methods in {@link Meta}.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract updateRegistration(userid:number, info:UserInfoMap, current:iceNS0.Ice.Current):PromiseLike<void>|void;
        /**
         * Per-server interface. This includes all methods for configuring and altering
         * the state of a single virtual server. You can retrieve a pointer to this interface
         * from one of the methods in {@link Meta}.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract getRegistration(userid:number, current:iceNS0.Ice.Current):PromiseLike<UserInfoMap>|UserInfoMap;
        /**
         * Per-server interface. This includes all methods for configuring and altering
         * the state of a single virtual server. You can retrieve a pointer to this interface
         * from one of the methods in {@link Meta}.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract getRegisteredUsers(filter:string, current:iceNS0.Ice.Current):PromiseLike<NameMap>|NameMap;
        /**
         * Per-server interface. This includes all methods for configuring and altering
         * the state of a single virtual server. You can retrieve a pointer to this interface
         * from one of the methods in {@link Meta}.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract verifyPassword(name:string, pw:string, current:iceNS0.Ice.Current):PromiseLike<number>|number;
        /**
         * Per-server interface. This includes all methods for configuring and altering
         * the state of a single virtual server. You can retrieve a pointer to this interface
         * from one of the methods in {@link Meta}.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract getTexture(userid:number, current:iceNS0.Ice.Current):PromiseLike<Texture>|Texture;
        /**
         * Per-server interface. This includes all methods for configuring and altering
         * the state of a single virtual server. You can retrieve a pointer to this interface
         * from one of the methods in {@link Meta}.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract setTexture(userid:number, tex:Texture, current:iceNS0.Ice.Current):PromiseLike<void>|void;
        /**
         * Per-server interface. This includes all methods for configuring and altering
         * the state of a single virtual server. You can retrieve a pointer to this interface
         * from one of the methods in {@link Meta}.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract getUptime(current:iceNS0.Ice.Current):PromiseLike<number>|number;
        /**
         * Per-server interface. This includes all methods for configuring and altering
         * the state of a single virtual server. You can retrieve a pointer to this interface
         * from one of the methods in {@link Meta}.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract updateCertificate(certificate:string, privateKey:string, passphrase:string, current:iceNS0.Ice.Current):PromiseLike<void>|void;
        /**
         * Obtains the Slice type ID of this type.
         * @return The return value is always "::Murmur::Server".
         */
        static ice_staticId():string;
    }

    abstract class MetaCallbackPrx extends iceNS0.Ice.ObjectPrx
    {
        /**
         * Called when a server is started. The server is up and running when this event is sent, so all methods that
         * need a running server will work.
         * @param srv Interface for started server.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        started(srv:ServerPrx, context?:Map<string, string>):iceNS0.Ice.AsyncResult<void>;
        /**
         * Called when a server is stopped. The server is already stopped when this event is sent, so no methods that
         * need a running server will work.
         * @param srv Interface for started server.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        stopped(srv:ServerPrx, context?:Map<string, string>):iceNS0.Ice.AsyncResult<void>;

        /**
         * Downcasts a proxy without confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @return A proxy with the requested type.
         */
        static uncheckedCast(prx:iceNS0.Ice.ObjectPrx, facet?:string):MetaCallbackPrx;
        /**
         * Downcasts a proxy after confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @param facet A facet name.
         * @param context The context map for the invocation.
         * @return A proxy with the requested type and facet, or nil if the target proxy is nil or the target
         * object does not support the requested type.
         */
        static checkedCast(prx:iceNS0.Ice.ObjectPrx, facet?:string, contex?:Map<string, string>):iceNS0.Ice.AsyncResult<MetaCallbackPrx>;
    }

    abstract class MetaCallback extends iceNS0.Ice.Object
    {
        /**
         * Callback interface for Meta. You can supply an implementation of this to receive notifications
         * when servers are stopped or started.
         * If an added callback ever throws an exception or goes away, it will be automatically removed.
         * Please note that all callbacks are done asynchronously; murmur does not wait for the callback to
         * complete before continuing processing.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         * @see ServerCallback
         * @see Meta.addCallback
         */
        abstract started(srv:ServerPrx, current:iceNS0.Ice.Current):PromiseLike<void>|void;
        /**
         * Callback interface for Meta. You can supply an implementation of this to receive notifications
         * when servers are stopped or started.
         * If an added callback ever throws an exception or goes away, it will be automatically removed.
         * Please note that all callbacks are done asynchronously; murmur does not wait for the callback to
         * complete before continuing processing.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         * @see ServerCallback
         * @see Meta.addCallback
         */
        abstract stopped(srv:ServerPrx, current:iceNS0.Ice.Current):PromiseLike<void>|void;
        /**
         * Obtains the Slice type ID of this type.
         * @return The return value is always "::Murmur::MetaCallback".
         */
        static ice_staticId():string;
    }

    type ServerList = ServerPrx[];

    class ServerListHelper
    {
        static write(outs:iceNS0.Ice.OutputStream, value:ServerList):void;
        static read(ins:iceNS0.Ice.InputStream):ServerList;
    }

    abstract class MetaPrx extends iceNS0.Ice.ObjectPrx
    {
        /**
         * Fetch interface to specific server.
         * @param id Server ID. See {@link Server.getId}.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        getServer(id:number, context?:Map<string, string>):iceNS0.Ice.AsyncResult<ServerPrx>;
        /**
         * Create a new server. Call {@link Server.getId} on the returned interface to find it's ID.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        newServer(context?:Map<string, string>):iceNS0.Ice.AsyncResult<ServerPrx>;
        /**
         * Fetch list of all currently running servers.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        getBootedServers(context?:Map<string, string>):iceNS0.Ice.AsyncResult<ServerList>;
        /**
         * Fetch list of all defined servers.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        getAllServers(context?:Map<string, string>):iceNS0.Ice.AsyncResult<ServerList>;
        /**
         * Fetch default configuraion. This returns the configuration items that were set in the configuration file, or
         * the built-in default. The individual servers will use these values unless they have been overridden in the
         * server specific configuration. The only special case is the port, which defaults to the value defined here +
         * the servers ID - 1 (so that virtual server #1 uses the defined port, server #2 uses port+1 etc).
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        getDefaultConf(context?:Map<string, string>):iceNS0.Ice.AsyncResult<ConfigMap>;
        /**
         * Fetch version of Murmur.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        getVersion(context?:Map<string, string>):iceNS0.Ice.AsyncResult<[number, number, number, string]>;
        /**
         * Add a callback. The callback will receive notifications when servers are started or stopped.
         * @param cb Callback interface which will receive notifications.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        addCallback(cb:MetaCallbackPrx, context?:Map<string, string>):iceNS0.Ice.AsyncResult<void>;
        /**
         * Remove a callback.
         * @param cb Callback interface to be removed.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        removeCallback(cb:MetaCallbackPrx, context?:Map<string, string>):iceNS0.Ice.AsyncResult<void>;
        /**
         * Get murmur uptime.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        getUptime(context?:Map<string, string>):iceNS0.Ice.AsyncResult<number>;
        /**
         * Get slice file.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        getSlice(context?:Map<string, string>):iceNS0.Ice.AsyncResult<string>;
        /**
         * Returns a checksum dict for the slice file.
         * @param context The Context map to send with the invocation.
         * @return The asynchronous result object for the invocation.
         */
        getSliceChecksums(context?:Map<string, string>):iceNS0.Ice.AsyncResult<iceNS0.Ice.SliceChecksumDict>;

        /**
         * Downcasts a proxy without confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @return A proxy with the requested type.
         */
        static uncheckedCast(prx:iceNS0.Ice.ObjectPrx, facet?:string):MetaPrx;
        /**
         * Downcasts a proxy after confirming the target object's type via a remote invocation.
         * @param prx The target proxy.
         * @param facet A facet name.
         * @param context The context map for the invocation.
         * @return A proxy with the requested type and facet, or nil if the target proxy is nil or the target
         * object does not support the requested type.
         */
        static checkedCast(prx:iceNS0.Ice.ObjectPrx, facet?:string, contex?:Map<string, string>):iceNS0.Ice.AsyncResult<MetaPrx>;
    }

    abstract class Meta extends iceNS0.Ice.Object
    {
        /**
         * This is the meta interface. It is primarily used for retrieving the {@link Server} interfaces for each individual server.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract getServer(id:number, current:iceNS0.Ice.Current):PromiseLike<ServerPrx>|ServerPrx;
        /**
         * This is the meta interface. It is primarily used for retrieving the {@link Server} interfaces for each individual server.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract newServer(current:iceNS0.Ice.Current):PromiseLike<ServerPrx>|ServerPrx;
        /**
         * This is the meta interface. It is primarily used for retrieving the {@link Server} interfaces for each individual server.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract getBootedServers(current:iceNS0.Ice.Current):PromiseLike<ServerList>|ServerList;
        /**
         * This is the meta interface. It is primarily used for retrieving the {@link Server} interfaces for each individual server.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract getAllServers(current:iceNS0.Ice.Current):PromiseLike<ServerList>|ServerList;
        /**
         * This is the meta interface. It is primarily used for retrieving the {@link Server} interfaces for each individual server.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract getDefaultConf(current:iceNS0.Ice.Current):PromiseLike<ConfigMap>|ConfigMap;
        /**
         * This is the meta interface. It is primarily used for retrieving the {@link Server} interfaces for each individual server.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract getVersion(current:iceNS0.Ice.Current):PromiseLike<[number, number, number, string]>|[number, number, number, string];
        /**
         * This is the meta interface. It is primarily used for retrieving the {@link Server} interfaces for each individual server.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract addCallback(cb:MetaCallbackPrx, current:iceNS0.Ice.Current):PromiseLike<void>|void;
        /**
         * This is the meta interface. It is primarily used for retrieving the {@link Server} interfaces for each individual server.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract removeCallback(cb:MetaCallbackPrx, current:iceNS0.Ice.Current):PromiseLike<void>|void;
        /**
         * This is the meta interface. It is primarily used for retrieving the {@link Server} interfaces for each individual server.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract getUptime(current:iceNS0.Ice.Current):PromiseLike<number>|number;
        /**
         * This is the meta interface. It is primarily used for retrieving the {@link Server} interfaces for each individual server.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract getSlice(current:iceNS0.Ice.Current):PromiseLike<string>|string;
        /**
         * This is the meta interface. It is primarily used for retrieving the {@link Server} interfaces for each individual server.
         * @param current The Current object for the invocation.
         * @return The result or a promise like object that will be resolved with the result of the invocation.
         */
        abstract getSliceChecksums(current:iceNS0.Ice.Current):PromiseLike<iceNS0.Ice.SliceChecksumDict>|iceNS0.Ice.SliceChecksumDict;
        /**
         * Obtains the Slice type ID of this type.
         * @return The return value is always "::Murmur::Meta".
         */
        static ice_staticId():string;
    }
}
